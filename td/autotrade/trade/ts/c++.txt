int CStockAccount::LogonBackend(ma::IDBEngine *pclsDBEngine, MACLIHANDLE hHandle, GxReqSender regSender /* = SENDER_TS */)
{
	char szTempbuf[1024] = {0};
	int nReqid = GetReqId();
	InsertRequestSerial(pclsDBEngine, nReqid, FUNC_LOGIN, "", regSender);

	char szMsgId[200] = {0};
	maCli_BeginWrite(hHandle);
	char cFunType = 'Q';//查询
	SetPacketHead(hHandle, FUNC_LOGIN, szMsgId, sizeof(szMsgId), cFunType);
	maCli_SetValueS(hHandle,"Z", FID_ACCT_TYPE);
	maCli_SetValueS(hHandle, m_sAccountID.c_str(), FID_ACCT_ID);
	maCli_SetValueS(hHandle, "0", FID_USE_SCOPE);
	maCli_SetValueS(hHandle, m_sAccountID.c_str(), FID_ENCRYPT_KEY);
	maCli_SetValueS(hHandle, "0", FID_AUTH_TYPE);
	char szVersion[32] = {0};
	maCli_GetVersion(hHandle, szVersion, sizeof(szVersion));
	maCli_SetValueS(hHandle, szVersion, FID_SESSION);

	char szBufAuthData[128]={0};
	maCli_ComEncrypt(hHandle, szBufAuthData, sizeof(szBufAuthData), m_sPwd.c_str(), m_sAccountID.c_str());
	maCli_SetValueS(hHandle, szBufAuthData, FID_AUTH_DATA);
	maCli_EndWrite(hHandle);
	unsigned char *pMsgData = NULL;
	int nMsgLen = 0;
	maCli_Make(hHandle, &pMsgData, &nMsgLen);

// 	int nLen = SetEagleMsgHead(szTempbuf, sizeof(szTempbuf) - 1, nReqid, FUNC_LOGIN, szMsgId);
// 	snprintf(szTempbuf + nLen, nMsgLen, "%s", pMsgData );
// 	nLen += nMsgLen;
// 
// 	int iSendRet = SendMsg(szTempbuf, nLen);
	int iSendRet = SendRequestMessage(nReqid, FUNC_LOGIN, szMsgId, (char *)pMsgData, nMsgLen);
	if(iSendRet)
	{
		LOG4CPLUS_FATAL_FMT(g_logger, LOG4CPLUS_TEXT("请求：%S连接交易网关，指令发送失败:%d"), m_sAccountID.c_str(), iSendRet);
		m_accountStatus = ACCOUNT_STATUS_LOGON_FAIL;
		SetlastError("连接异常,登录发送失败!");
		m_lpOwner->OnTradingAcctlogged(m_sAccountID.c_str(), false);
		DeleteRequestSerial(pclsDBEngine, nReqid);
	}
	else
	{
		LOG4CPLUS_INFO_FMT(g_logger, LOG4CPLUS_TEXT("请求：%S连接交易网关，指令发送成功！"), m_sAccountID.c_str());
		m_accountStatus = ACCOUNT_STATUS_LOGGING;
	}	

	return iSendRet;
}
int CGSAccount::SendRequestMessage(int nReqid, int nFuncId, char *pstrMsgid, char *pstrBiz, int nBizLen)
{	
	ReallocReqBuf(nBizLen);
	int nLen = SetEagleMsgHead(m_pstrReqBuf, 256, nReqid, nFuncId, pstrMsgid);
	//string strBase64;
	CBase64 clsBase64;
	clsBase64.EncodeBuffer(pstrBiz, nBizLen, m_pstrReqBuf + nLen);
	//base64_encode((const unsigned char *)pstrBiz, nBizLen, strBase64);
	//int nMsgLen = strBase64.length();
	//snprintf(m_pstrReqBuf + nLen, nMsgLen + 1, "%s\0", strBase64.c_str());
	//nLen += nMsgLen;
	nLen = strlen(m_pstrReqBuf);
	m_pstrReqBuf[nLen] =0x1;
	m_pstrReqBuf[++nLen] = 0;

	if(m_accountStatus != ACCOUNT_STATUS_LOGGED_ON)
	{
		LOG4CPLUS_INFO(g_logger, LOG4CPLUS_TEXT("发送后台请求失败:未登录, 功能:") << nFuncId);	
		return -1;
	}

	LOG4CPLUS_INFO_FMT(g_logger, LOG4CPLUS_TEXT("[CGSAccount::SendRequestMessage]发送后台请求:%S"), m_pstrReqBuf);
	return GetEagle().SendMsg(m_sAccountID.c_str(), m_pstrReqBuf, nLen);
}
int  CGSAccount::SetEagleMsgHead(char *pstrMsg, int nMaxLen, int nRequestId, int nFuncId, const char *pcstrMsgid,int nCmdId)
{
	return snprintf(pstrMsg, nMaxLen, "%d\1%d\1%s\1%d\1%s\1",
		nCmdId,
		nRequestId,
		m_sAccountID.c_str(),
		nFuncId,
		pcstrMsgid);
}

_ma = WinDLL("maCliApi.dll")
hHandle = c_void_p(0)
_ma.maCli_Init(byref(hHandle))
_ma.maCli_BeginWrite(hHandle)
_ma.maCli_SetValueS(hHandle, c_char_p("110000035019"), c_char_p("9081"))
_ma.maCli_SetValueS(hHandle, c_char_p("Z"), c_char_p("9083"))
szVersion = create_string_buffer(32)
_ma.maCli_GetVersion(hHandle, szVersion, len(szVersion))
_ma.maCli_SetValueS(hHandle, szVersion, c_char_p("8814"))
szAuthData = create_string_buffer(128)
_ma.maCli_ComEncrypt(hHandle, szAuthData, len(szAuthData), c_char_p("110000035019"), c_char_p("111111"))
_ma.maCli_SetValueS(hHandle, szAuthData, c_char_p("9084"))
_ma.maCli_EndWrite(hHandle)

ilen = c_int(0)
pBizData = c_char_p(0)
_ma.maCli_Make(hHandle, byref(pBizData), byref(ilen))
bizdata = create_string_buffer(1024)
memmove(bizdata, pBizData, ilen)


